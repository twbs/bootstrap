{
  "version": 3,
  "sources": ["../../../../node_modules/inherits/inherits_browser.js", "../../../../node_modules/events/events.js", "../../../../node_modules/queue/index.js", "../../../../node_modules/image-size/dist/types/bmp.js", "../../../../node_modules/image-size/dist/types/ico.js", "../../../../node_modules/image-size/dist/types/cur.js", "../../../../node_modules/image-size/dist/types/dds.js", "../../../../node_modules/image-size/dist/types/gif.js", "../../../../node_modules/image-size/dist/types/icns.js", "../../../../node_modules/image-size/dist/types/j2c.js", "../../../../node_modules/image-size/dist/types/jp2.js", "../../../../node_modules/image-size/dist/readUInt.js", "../../../../node_modules/image-size/dist/types/jpg.js", "../../../../node_modules/image-size/dist/types/ktx.js", "../../../../node_modules/image-size/dist/types/png.js", "../../../../node_modules/image-size/dist/types/pnm.js", "../../../../node_modules/image-size/dist/types/psd.js", "../../../../node_modules/image-size/dist/types/svg.js", "../../../../node_modules/image-size/dist/types/tga.js", "../../../../node_modules/image-size/dist/types/tiff.js", "../../../../node_modules/image-size/dist/types/webp.js", "../../../../node_modules/image-size/dist/types.js", "../../../../node_modules/image-size/dist/detector.js", "../../../../node_modules/image-size/dist/index.js"],
  "sourcesContent": ["if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n", "var inherits = require('inherits')\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = Queue\nmodule.exports.default = Queue\n\nfunction Queue (options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options)\n  }\n\n  EventEmitter.call(this)\n  options = options || {}\n  this.concurrency = options.concurrency || Infinity\n  this.timeout = options.timeout || 0\n  this.autostart = options.autostart || false\n  this.results = options.results || null\n  this.pending = 0\n  this.session = 0\n  this.running = false\n  this.jobs = []\n  this.timers = {}\n}\ninherits(Queue, EventEmitter)\n\nvar arrayMethods = [\n  'pop',\n  'shift',\n  'indexOf',\n  'lastIndexOf'\n]\n\narrayMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    return Array.prototype[method].apply(this.jobs, arguments)\n  }\n})\n\nQueue.prototype.slice = function (begin, end) {\n  this.jobs = this.jobs.slice(begin, end)\n  return this\n}\n\nQueue.prototype.reverse = function () {\n  this.jobs.reverse()\n  return this\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n]\n\narrayAddMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments)\n    if (this.autostart) {\n      this.start()\n    }\n    return methodResult\n  }\n})\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function () {\n    return this.pending + this.jobs.length\n  }\n})\n\nQueue.prototype.start = function (cb) {\n  if (cb) {\n    callOnErrorOrEnd.call(this, cb)\n  }\n\n  this.running = true\n\n  if (this.pending >= this.concurrency) {\n    return\n  }\n\n  if (this.jobs.length === 0) {\n    if (this.pending === 0) {\n      done.call(this)\n    }\n    return\n  }\n\n  var self = this\n  var job = this.jobs.shift()\n  var once = true\n  var session = this.session\n  var timeoutId = null\n  var didTimeout = false\n  var resultIndex = null\n  var timeout = job.hasOwnProperty('timeout') ? job.timeout : this.timeout\n\n  function next (err, result) {\n    if (once && self.session === session) {\n      once = false\n      self.pending--\n      if (timeoutId !== null) {\n        delete self.timers[timeoutId]\n        clearTimeout(timeoutId)\n      }\n\n      if (err) {\n        self.emit('error', err, job)\n      } else if (didTimeout === false) {\n        if (resultIndex !== null) {\n          self.results[resultIndex] = Array.prototype.slice.call(arguments, 1)\n        }\n        self.emit('success', result, job)\n      }\n\n      if (self.session === session) {\n        if (self.pending === 0 && self.jobs.length === 0) {\n          done.call(self)\n        } else if (self.running) {\n          self.start()\n        }\n      }\n    }\n  }\n\n  if (timeout) {\n    timeoutId = setTimeout(function () {\n      didTimeout = true\n      if (self.listeners('timeout').length > 0) {\n        self.emit('timeout', next, job)\n      } else {\n        next()\n      }\n    }, timeout)\n    this.timers[timeoutId] = timeoutId\n  }\n\n  if (this.results) {\n    resultIndex = this.results.length\n    this.results[resultIndex] = null\n  }\n\n  this.pending++\n  self.emit('start', job)\n  var promise = job(next)\n  if (promise && promise.then && typeof promise.then === 'function') {\n    promise.then(function (result) {\n      return next(null, result)\n    }).catch(function (err) {\n      return next(err || true)\n    })\n  }\n\n  if (this.running && this.jobs.length > 0) {\n    this.start()\n  }\n}\n\nQueue.prototype.stop = function () {\n  this.running = false\n}\n\nQueue.prototype.end = function (err) {\n  clearTimers.call(this)\n  this.jobs.length = 0\n  this.pending = 0\n  done.call(this, err)\n}\n\nfunction clearTimers () {\n  for (var key in this.timers) {\n    var timeoutId = this.timers[key]\n    delete this.timers[key]\n    clearTimeout(timeoutId)\n  }\n}\n\nfunction callOnErrorOrEnd (cb) {\n  var self = this\n  this.on('error', onerror)\n  this.on('end', onend)\n\n  function onerror (err) { self.end(err) }\n  function onend (err) {\n    self.removeListener('error', onerror)\n    self.removeListener('end', onend)\n    cb(err, this.results)\n  }\n}\n\nfunction done (err) {\n  this.session++\n  this.running = false\n  this.emit('end', err)\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BMP = void 0;\nexports.BMP = {\n    validate(buffer) {\n        return ('BM' === buffer.toString('ascii', 0, 2));\n    },\n    calculate(buffer) {\n        return {\n            height: Math.abs(buffer.readInt32LE(22)),\n            width: buffer.readUInt32LE(18)\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICO = void 0;\nconst TYPE_ICON = 1;\n/**\n * ICON Header\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 2    | Reserved. Must always be 0.  |\n * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |\n * | 4      | 2    | Number of images in the file. |\n *\n */\nconst SIZE_HEADER = 2 + 2 + 2; // 6\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |\n * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |\n * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |\n * | 3      | 1    | Reserved. Should be 0. |\n * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |\n * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |\n * | 6      | 2    | ICO format: Bits per pixel. |\n * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |\n * | 8      | 4    | The size of the image's data in bytes |\n * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |\n *\n */\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16\nfunction getSizeFromOffset(buffer, offset) {\n    const value = buffer.readUInt8(offset);\n    return value === 0 ? 256 : value;\n}\nfunction getImageSize(buffer, imageIndex) {\n    const offset = SIZE_HEADER + (imageIndex * SIZE_IMAGE_ENTRY);\n    return {\n        height: getSizeFromOffset(buffer, offset + 1),\n        width: getSizeFromOffset(buffer, offset)\n    };\n}\nexports.ICO = {\n    validate(buffer) {\n        const reserved = buffer.readUInt16LE(0);\n        const imageCount = buffer.readUInt16LE(4);\n        if (reserved !== 0 || imageCount === 0) {\n            return false;\n        }\n        const imageType = buffer.readUInt16LE(2);\n        return imageType === TYPE_ICON;\n    },\n    calculate(buffer) {\n        const nbImages = buffer.readUInt16LE(4);\n        const imageSize = getImageSize(buffer, 0);\n        if (nbImages === 1) {\n            return imageSize;\n        }\n        const imgs = [imageSize];\n        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n            imgs.push(getImageSize(buffer, imageIndex));\n        }\n        const result = {\n            height: imageSize.height,\n            images: imgs,\n            width: imageSize.width\n        };\n        return result;\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CUR = void 0;\nconst ico_1 = require(\"./ico\");\nconst TYPE_CURSOR = 2;\nexports.CUR = {\n    validate(buffer) {\n        const reserved = buffer.readUInt16LE(0);\n        const imageCount = buffer.readUInt16LE(4);\n        if (reserved !== 0 || imageCount === 0) {\n            return false;\n        }\n        const imageType = buffer.readUInt16LE(2);\n        return imageType === TYPE_CURSOR;\n    },\n    calculate(buffer) {\n        return ico_1.ICO.calculate(buffer);\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DDS = void 0;\nexports.DDS = {\n    validate(buffer) {\n        return buffer.readUInt32LE(0) === 0x20534444;\n    },\n    calculate(buffer) {\n        return {\n            height: buffer.readUInt32LE(12),\n            width: buffer.readUInt32LE(16)\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GIF = void 0;\nconst gifRegexp = /^GIF8[79]a/;\nexports.GIF = {\n    validate(buffer) {\n        const signature = buffer.toString('ascii', 0, 6);\n        return (gifRegexp.test(signature));\n    },\n    calculate(buffer) {\n        return {\n            height: buffer.readUInt16LE(8),\n            width: buffer.readUInt16LE(6)\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICNS = void 0;\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n */\nconst SIZE_HEADER = 4 + 4; // 8\nconst FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n */\nconst ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\nconst ICON_TYPE_SIZE = {\n    ICON: 32,\n    'ICN#': 32,\n    // m => 16 x 16\n    'icm#': 16,\n    icm4: 16,\n    icm8: 16,\n    // s => 16 x 16\n    'ics#': 16,\n    ics4: 16,\n    ics8: 16,\n    is32: 16,\n    s8mk: 16,\n    icp4: 16,\n    // l => 32 x 32\n    icl4: 32,\n    icl8: 32,\n    il32: 32,\n    l8mk: 32,\n    icp5: 32,\n    ic11: 32,\n    // h => 48 x 48\n    ich4: 48,\n    ich8: 48,\n    ih32: 48,\n    h8mk: 48,\n    // . => 64 x 64\n    icp6: 64,\n    ic12: 32,\n    // t => 128 x 128\n    it32: 128,\n    t8mk: 128,\n    ic07: 128,\n    // . => 256 x 256\n    ic08: 256,\n    ic13: 256,\n    // . => 512 x 512\n    ic09: 512,\n    ic14: 512,\n    // . => 1024 x 1024\n    ic10: 1024,\n};\nfunction readImageHeader(buffer, imageOffset) {\n    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n    return [\n        buffer.toString('ascii', imageOffset, imageLengthOffset),\n        buffer.readUInt32BE(imageLengthOffset)\n    ];\n}\nfunction getImageSize(type) {\n    const size = ICON_TYPE_SIZE[type];\n    return { width: size, height: size, type };\n}\nexports.ICNS = {\n    validate(buffer) {\n        return ('icns' === buffer.toString('ascii', 0, 4));\n    },\n    calculate(buffer) {\n        const bufferLength = buffer.length;\n        const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);\n        let imageOffset = SIZE_HEADER;\n        let imageHeader = readImageHeader(buffer, imageOffset);\n        let imageSize = getImageSize(imageHeader[0]);\n        imageOffset += imageHeader[1];\n        if (imageOffset === fileLength) {\n            return imageSize;\n        }\n        const result = {\n            height: imageSize.height,\n            images: [imageSize],\n            width: imageSize.width\n        };\n        while (imageOffset < fileLength && imageOffset < bufferLength) {\n            imageHeader = readImageHeader(buffer, imageOffset);\n            imageSize = getImageSize(imageHeader[0]);\n            imageOffset += imageHeader[1];\n            result.images.push(imageSize);\n        }\n        return result;\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.J2C = void 0;\nexports.J2C = {\n    validate(buffer) {\n        // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC\n        return buffer.toString('hex', 0, 4) === 'ff4fff51';\n    },\n    calculate(buffer) {\n        return {\n            height: buffer.readUInt32BE(12),\n            width: buffer.readUInt32BE(8),\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JP2 = void 0;\nconst BoxTypes = {\n    ftyp: '66747970',\n    ihdr: '69686472',\n    jp2h: '6a703268',\n    jp__: '6a502020',\n    rreq: '72726571',\n    xml_: '786d6c20'\n};\nconst calculateRREQLength = (box) => {\n    const unit = box.readUInt8(0);\n    let offset = 1 + (2 * unit);\n    const numStdFlags = box.readUInt16BE(offset);\n    const flagsLength = numStdFlags * (2 + unit);\n    offset = offset + 2 + flagsLength;\n    const numVendorFeatures = box.readUInt16BE(offset);\n    const featuresLength = numVendorFeatures * (16 + unit);\n    return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box) => {\n    return {\n        height: box.readUInt32BE(4),\n        width: box.readUInt32BE(8),\n    };\n};\nexports.JP2 = {\n    validate(buffer) {\n        const signature = buffer.toString('hex', 4, 8);\n        const signatureLength = buffer.readUInt32BE(0);\n        if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n            return false;\n        }\n        const ftypeBoxStart = signatureLength + 4;\n        const ftypBoxLength = buffer.readUInt32BE(signatureLength);\n        const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n        return ftypBox.toString('hex', 0, 4) === BoxTypes.ftyp;\n    },\n    calculate(buffer) {\n        const signatureLength = buffer.readUInt32BE(0);\n        const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);\n        let offset = signatureLength + 4 + ftypBoxLength;\n        const nextBoxType = buffer.toString('hex', offset, offset + 4);\n        switch (nextBoxType) {\n            case BoxTypes.rreq:\n                // WHAT ARE THESE 4 BYTES?????\n                // eslint-disable-next-line no-case-declarations\n                const MAGIC = 4;\n                offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));\n                return parseIHDR(buffer.slice(offset + 8, offset + 24));\n            case BoxTypes.jp2h:\n                return parseIHDR(buffer.slice(offset + 8, offset + 24));\n            default:\n                throw new TypeError('Unsupported header found: ' + buffer.toString('ascii', offset, offset + 4));\n        }\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readUInt = void 0;\n// Abstract reading multi-byte unsigned integers\nfunction readUInt(buffer, bits, offset, isBigEndian) {\n    offset = offset || 0;\n    const endian = isBigEndian ? 'BE' : 'LE';\n    const methodName = ('readUInt' + bits + endian);\n    return buffer[methodName].call(buffer, offset);\n}\nexports.readUInt = readUInt;\n", "\"use strict\";\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JPG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n// Each entry is exactly 12 bytes\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(buffer) {\n    return (buffer.toString('hex', 2, 6) === EXIF_MARKER);\n}\nfunction extractSize(buffer, index) {\n    return {\n        height: buffer.readUInt16BE(index),\n        width: buffer.readUInt16BE(index + 2)\n    };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n    // TODO: assert that this contains 0x002A\n    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n    const idfOffset = 8;\n    // IDF osset works from right after the header bytes\n    // (so the offset includes the tiff byte align)\n    const offset = EXIF_HEADER_BYTES + idfOffset;\n    const idfDirectoryEntries = (0, readUInt_1.readUInt)(exifBlock, 16, offset, isBigEndian);\n    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + (directoryEntryNumber * IDF_ENTRY_BYTES);\n        const end = start + IDF_ENTRY_BYTES;\n        // Skip on corrupt EXIF blocks\n        if (start > exifBlock.length) {\n            return;\n        }\n        const block = exifBlock.slice(start, end);\n        const tagNumber = (0, readUInt_1.readUInt)(block, 16, 0, isBigEndian);\n        // 0x0112 (decimal: 274) is the `orientation` tag ID\n        if (tagNumber === 274) {\n            const dataFormat = (0, readUInt_1.readUInt)(block, 16, 2, isBigEndian);\n            if (dataFormat !== 3) {\n                return;\n            }\n            // unsinged int has 2 bytes per component\n            // if there would more than 4 bytes in total it's a pointer\n            const numberOfComponents = (0, readUInt_1.readUInt)(block, 32, 4, isBigEndian);\n            if (numberOfComponents !== 1) {\n                return;\n            }\n            return (0, readUInt_1.readUInt)(block, 16, 8, isBigEndian);\n        }\n    }\n}\nfunction validateExifBlock(buffer, index) {\n    // Skip APP1 Data Size\n    const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);\n    // Consider byte alignment\n    const byteAlign = exifBlock.toString('hex', EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n    // Ignore Empty EXIF. Validate byte alignment\n    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n    if (isBigEndian || isLittleEndian) {\n        return extractOrientation(exifBlock, isBigEndian);\n    }\n}\nfunction validateBuffer(buffer, index) {\n    // index should be within buffer limits\n    if (index > buffer.length) {\n        throw new TypeError('Corrupt JPG, exceeded buffer limits');\n    }\n    // Every JPEG block must begin with a 0xFF\n    if (buffer[index] !== 0xFF) {\n        throw new TypeError('Invalid JPG, marker table corrupted');\n    }\n}\nexports.JPG = {\n    validate(buffer) {\n        const SOIMarker = buffer.toString('hex', 0, 2);\n        return ('ffd8' === SOIMarker);\n    },\n    calculate(buffer) {\n        // Skip 4 chars, they are for signature\n        buffer = buffer.slice(4);\n        let orientation;\n        let next;\n        while (buffer.length) {\n            // read length of the next block\n            const i = buffer.readUInt16BE(0);\n            if (isEXIF(buffer)) {\n                orientation = validateExifBlock(buffer, i);\n            }\n            // ensure correct format\n            validateBuffer(buffer, i);\n            // 0xFFC0 is baseline standard(SOF)\n            // 0xFFC1 is baseline optimized(SOF)\n            // 0xFFC2 is progressive(SOF2)\n            next = buffer[i + 1];\n            if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n                const size = extractSize(buffer, i + 5);\n                // TODO: is orientation=0 a valid answer here?\n                if (!orientation) {\n                    return size;\n                }\n                return {\n                    height: size.height,\n                    orientation,\n                    width: size.width\n                };\n            }\n            // move to the next block\n            buffer = buffer.slice(i + 2);\n        }\n        throw new TypeError('Invalid JPG, no size found');\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KTX = void 0;\nconst SIGNATURE = 'KTX 11';\nexports.KTX = {\n    validate(buffer) {\n        return SIGNATURE === buffer.toString('ascii', 1, 7);\n    },\n    calculate(buffer) {\n        return {\n            height: buffer.readUInt32LE(40),\n            width: buffer.readUInt32LE(36),\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNG = void 0;\nconst pngSignature = 'PNG\\r\\n\\x1a\\n';\nconst pngImageHeaderChunkName = 'IHDR';\n// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\nconst pngFriedChunkName = 'CgBI';\nexports.PNG = {\n    validate(buffer) {\n        if (pngSignature === buffer.toString('ascii', 1, 8)) {\n            let chunkName = buffer.toString('ascii', 12, 16);\n            if (chunkName === pngFriedChunkName) {\n                chunkName = buffer.toString('ascii', 28, 32);\n            }\n            if (chunkName !== pngImageHeaderChunkName) {\n                throw new TypeError('Invalid PNG');\n            }\n            return true;\n        }\n        return false;\n    },\n    calculate(buffer) {\n        if (buffer.toString('ascii', 12, 16) === pngFriedChunkName) {\n            return {\n                height: buffer.readUInt32BE(36),\n                width: buffer.readUInt32BE(32)\n            };\n        }\n        return {\n            height: buffer.readUInt32BE(20),\n            width: buffer.readUInt32BE(16)\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNM = void 0;\nconst PNMTypes = {\n    P1: 'pbm/ascii',\n    P2: 'pgm/ascii',\n    P3: 'ppm/ascii',\n    P4: 'pbm',\n    P5: 'pgm',\n    P6: 'ppm',\n    P7: 'pam',\n    PF: 'pfm'\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n    default: (lines) => {\n        let dimensions = [];\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line[0] === '#') {\n                continue;\n            }\n            dimensions = line.split(' ');\n            break;\n        }\n        if (dimensions.length === 2) {\n            return {\n                height: parseInt(dimensions[1], 10),\n                width: parseInt(dimensions[0], 10),\n            };\n        }\n        else {\n            throw new TypeError('Invalid PNM');\n        }\n    },\n    pam: (lines) => {\n        const size = {};\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line.length > 16 || line.charCodeAt(0) > 128) {\n                continue;\n            }\n            const [key, value] = line.split(' ');\n            if (key && value) {\n                size[key.toLowerCase()] = parseInt(value, 10);\n            }\n            if (size.height && size.width) {\n                break;\n            }\n        }\n        if (size.height && size.width) {\n            return {\n                height: size.height,\n                width: size.width\n            };\n        }\n        else {\n            throw new TypeError('Invalid PAM');\n        }\n    }\n};\nexports.PNM = {\n    validate(buffer) {\n        const signature = buffer.toString('ascii', 0, 2);\n        return Signatures.includes(signature);\n    },\n    calculate(buffer) {\n        const signature = buffer.toString('ascii', 0, 2);\n        const type = PNMTypes[signature];\n        // TODO: this probably generates garbage. move to a stream based parser\n        const lines = buffer.toString('ascii', 3).split(/[\\r\\n]+/);\n        const handler = handlers[type] || handlers.default;\n        return handler(lines);\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PSD = void 0;\nexports.PSD = {\n    validate(buffer) {\n        return ('8BPS' === buffer.toString('ascii', 0, 4));\n    },\n    calculate(buffer) {\n        return {\n            height: buffer.readUInt32BE(14),\n            width: buffer.readUInt32BE(18)\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SVG = void 0;\nconst svgReg = /<svg\\s([^>\"']|\"[^\"]*\"|'[^']*')*>/;\nconst extractorRegExps = {\n    height: /\\sheight=(['\"])([^%]+?)\\1/,\n    root: svgReg,\n    viewbox: /\\sviewBox=(['\"])(.+?)\\1/i,\n    width: /\\swidth=(['\"])([^%]+?)\\1/,\n};\nconst INCH_CM = 2.54;\nconst units = {\n    in: 96,\n    cm: 96 / INCH_CM,\n    em: 16,\n    ex: 8,\n    m: 96 / INCH_CM * 100,\n    mm: 96 / INCH_CM / 10,\n    pc: 96 / 72 / 12,\n    pt: 96 / 72,\n    px: 1\n};\nconst unitsReg = new RegExp(`^([0-9.]+(?:e\\\\d+)?)(${Object.keys(units).join('|')})?$`);\nfunction parseLength(len) {\n    const m = unitsReg.exec(len);\n    if (!m) {\n        return undefined;\n    }\n    return Math.round(Number(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n    const bounds = viewbox.split(' ');\n    return {\n        height: parseLength(bounds[3]),\n        width: parseLength(bounds[2])\n    };\n}\nfunction parseAttributes(root) {\n    const width = root.match(extractorRegExps.width);\n    const height = root.match(extractorRegExps.height);\n    const viewbox = root.match(extractorRegExps.viewbox);\n    return {\n        height: height && parseLength(height[2]),\n        viewbox: viewbox && parseViewbox(viewbox[2]),\n        width: width && parseLength(width[2]),\n    };\n}\nfunction calculateByDimensions(attrs) {\n    return {\n        height: attrs.height,\n        width: attrs.width,\n    };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n    const ratio = viewbox.width / viewbox.height;\n    if (attrs.width) {\n        return {\n            height: Math.floor(attrs.width / ratio),\n            width: attrs.width,\n        };\n    }\n    if (attrs.height) {\n        return {\n            height: attrs.height,\n            width: Math.floor(attrs.height * ratio),\n        };\n    }\n    return {\n        height: viewbox.height,\n        width: viewbox.width,\n    };\n}\nexports.SVG = {\n    validate(buffer) {\n        const str = String(buffer);\n        return svgReg.test(str);\n    },\n    calculate(buffer) {\n        const root = buffer.toString('utf8').match(extractorRegExps.root);\n        if (root) {\n            const attrs = parseAttributes(root[0]);\n            if (attrs.width && attrs.height) {\n                return calculateByDimensions(attrs);\n            }\n            if (attrs.viewbox) {\n                return calculateByViewbox(attrs, attrs.viewbox);\n            }\n        }\n        throw new TypeError('Invalid SVG');\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TGA = void 0;\nexports.TGA = {\n    validate(buffer) {\n        return buffer.readUInt16LE(0) === 0 && buffer.readUInt16LE(4) === 0;\n    },\n    calculate(buffer) {\n        return {\n            height: buffer.readUInt16LE(14),\n            width: buffer.readUInt16LE(12),\n        };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TIFF = void 0;\n// based on http://www.compix.com/fileformattif.htm\n// TO-DO: support big-endian as well\nconst fs = require(\"fs\");\nconst readUInt_1 = require(\"../readUInt\");\n// Read IFD (image-file-directory) into a buffer\nfunction readIFD(buffer, filepath, isBigEndian) {\n    const ifdOffset = (0, readUInt_1.readUInt)(buffer, 32, 4, isBigEndian);\n    // read only till the end of the file\n    let bufferSize = 1024;\n    const fileSize = fs.statSync(filepath).size;\n    if (ifdOffset + bufferSize > fileSize) {\n        bufferSize = fileSize - ifdOffset - 10;\n    }\n    // populate the buffer\n    const endBuffer = Buffer.alloc(bufferSize);\n    const descriptor = fs.openSync(filepath, 'r');\n    fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);\n    fs.closeSync(descriptor);\n    return endBuffer.slice(2);\n}\n// TIFF values seem to be messed up on Big-Endian, this helps\nfunction readValue(buffer, isBigEndian) {\n    const low = (0, readUInt_1.readUInt)(buffer, 16, 8, isBigEndian);\n    const high = (0, readUInt_1.readUInt)(buffer, 16, 10, isBigEndian);\n    return (high << 16) + low;\n}\n// move to the next tag\nfunction nextTag(buffer) {\n    if (buffer.length > 24) {\n        return buffer.slice(12);\n    }\n}\n// Extract IFD tags from TIFF metadata\nfunction extractTags(buffer, isBigEndian) {\n    const tags = {};\n    let temp = buffer;\n    while (temp && temp.length) {\n        const code = (0, readUInt_1.readUInt)(temp, 16, 0, isBigEndian);\n        const type = (0, readUInt_1.readUInt)(temp, 16, 2, isBigEndian);\n        const length = (0, readUInt_1.readUInt)(temp, 32, 4, isBigEndian);\n        // 0 means end of IFD\n        if (code === 0) {\n            break;\n        }\n        else {\n            // 256 is width, 257 is height\n            // if (code === 256 || code === 257) {\n            if (length === 1 && (type === 3 || type === 4)) {\n                tags[code] = readValue(temp, isBigEndian);\n            }\n            // move to the next tag\n            temp = nextTag(temp);\n        }\n    }\n    return tags;\n}\n// Test if the TIFF is Big Endian or Little Endian\nfunction determineEndianness(buffer) {\n    const signature = buffer.toString('ascii', 0, 2);\n    if ('II' === signature) {\n        return 'LE';\n    }\n    else if ('MM' === signature) {\n        return 'BE';\n    }\n}\nconst signatures = [\n    // '492049', // currently not supported\n    '49492a00',\n    '4d4d002a', // Big Endian\n    // '4d4d002a', // BigTIFF > 4GB. currently not supported\n];\nexports.TIFF = {\n    validate(buffer) {\n        return signatures.includes(buffer.toString('hex', 0, 4));\n    },\n    calculate(buffer, filepath) {\n        if (!filepath) {\n            throw new TypeError('Tiff doesn\\'t support buffer');\n        }\n        // Determine BE/LE\n        const isBigEndian = determineEndianness(buffer) === 'BE';\n        // read the IFD\n        const ifdBuffer = readIFD(buffer, filepath, isBigEndian);\n        // extract the tags from the IFD\n        const tags = extractTags(ifdBuffer, isBigEndian);\n        const width = tags[256];\n        const height = tags[257];\n        if (!width || !height) {\n            throw new TypeError('Invalid Tiff. Missing tags');\n        }\n        return { height, width };\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WEBP = void 0;\nfunction calculateExtended(buffer) {\n    return {\n        height: 1 + buffer.readUIntLE(7, 3),\n        width: 1 + buffer.readUIntLE(4, 3)\n    };\n}\nfunction calculateLossless(buffer) {\n    return {\n        height: 1 + (((buffer[4] & 0xF) << 10) | (buffer[3] << 2) | ((buffer[2] & 0xC0) >> 6)),\n        width: 1 + (((buffer[2] & 0x3F) << 8) | buffer[1])\n    };\n}\nfunction calculateLossy(buffer) {\n    // `& 0x3fff` returns the last 14 bits\n    // TO-DO: include webp scaling in the calculations\n    return {\n        height: buffer.readInt16LE(8) & 0x3fff,\n        width: buffer.readInt16LE(6) & 0x3fff\n    };\n}\nexports.WEBP = {\n    validate(buffer) {\n        const riffHeader = 'RIFF' === buffer.toString('ascii', 0, 4);\n        const webpHeader = 'WEBP' === buffer.toString('ascii', 8, 12);\n        const vp8Header = 'VP8' === buffer.toString('ascii', 12, 15);\n        return (riffHeader && webpHeader && vp8Header);\n    },\n    calculate(buffer) {\n        const chunkHeader = buffer.toString('ascii', 12, 16);\n        buffer = buffer.slice(20, 30);\n        // Extended webp stream signature\n        if (chunkHeader === 'VP8X') {\n            const extendedHeader = buffer[0];\n            const validStart = (extendedHeader & 0xc0) === 0;\n            const validEnd = (extendedHeader & 0x01) === 0;\n            if (validStart && validEnd) {\n                return calculateExtended(buffer);\n            }\n            else {\n                // TODO: breaking change\n                throw new TypeError('Invalid WebP');\n            }\n        }\n        // Lossless webp stream signature\n        if (chunkHeader === 'VP8 ' && buffer[0] !== 0x2f) {\n            return calculateLossy(buffer);\n        }\n        // Lossy webp stream signature\n        const signature = buffer.toString('hex', 3, 6);\n        if (chunkHeader === 'VP8L' && signature !== '9d012a') {\n            return calculateLossless(buffer);\n        }\n        throw new TypeError('Invalid WebP');\n    }\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.typeHandlers = void 0;\n// load all available handlers explicitely for browserify support\nconst bmp_1 = require(\"./types/bmp\");\nconst cur_1 = require(\"./types/cur\");\nconst dds_1 = require(\"./types/dds\");\nconst gif_1 = require(\"./types/gif\");\nconst icns_1 = require(\"./types/icns\");\nconst ico_1 = require(\"./types/ico\");\nconst j2c_1 = require(\"./types/j2c\");\nconst jp2_1 = require(\"./types/jp2\");\nconst jpg_1 = require(\"./types/jpg\");\nconst ktx_1 = require(\"./types/ktx\");\nconst png_1 = require(\"./types/png\");\nconst pnm_1 = require(\"./types/pnm\");\nconst psd_1 = require(\"./types/psd\");\nconst svg_1 = require(\"./types/svg\");\nconst tga_1 = require(\"./types/tga\");\nconst tiff_1 = require(\"./types/tiff\");\nconst webp_1 = require(\"./types/webp\");\nexports.typeHandlers = {\n    bmp: bmp_1.BMP,\n    cur: cur_1.CUR,\n    dds: dds_1.DDS,\n    gif: gif_1.GIF,\n    icns: icns_1.ICNS,\n    ico: ico_1.ICO,\n    j2c: j2c_1.J2C,\n    jp2: jp2_1.JP2,\n    jpg: jpg_1.JPG,\n    ktx: ktx_1.KTX,\n    png: png_1.PNG,\n    pnm: pnm_1.PNM,\n    psd: psd_1.PSD,\n    svg: svg_1.SVG,\n    tga: tga_1.TGA,\n    tiff: tiff_1.TIFF,\n    webp: webp_1.WEBP,\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detector = void 0;\nconst types_1 = require(\"./types\");\nconst keys = Object.keys(types_1.typeHandlers);\n// This map helps avoid validating for every single image type\nconst firstBytes = {\n    0x38: 'psd',\n    0x42: 'bmp',\n    0x44: 'dds',\n    0x47: 'gif',\n    0x49: 'tiff',\n    0x4d: 'tiff',\n    0x52: 'webp',\n    0x69: 'icns',\n    0x89: 'png',\n    0xff: 'jpg'\n};\nfunction detector(buffer) {\n    const byte = buffer[0];\n    if (byte in firstBytes) {\n        const type = firstBytes[byte];\n        if (type && types_1.typeHandlers[type].validate(buffer)) {\n            return type;\n        }\n    }\n    const finder = (key) => types_1.typeHandlers[key].validate(buffer);\n    return keys.find(finder);\n}\nexports.detector = detector;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst queue_1 = require(\"queue\");\nconst types_1 = require(\"./types\");\nconst detector_1 = require(\"./detector\");\n// Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\nconst MaxBufferSize = 512 * 1024;\n// This queue is for async `fs` operations, to avoid reaching file-descriptor limits\nconst queue = new queue_1.default({ concurrency: 100, autostart: true });\nconst globalOptions = {\n    disabledFS: false,\n    disabledTypes: []\n};\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\nfunction lookup(buffer, filepath) {\n    // detect the file type.. don't rely on the extension\n    const type = (0, detector_1.detector)(buffer);\n    if (typeof type !== 'undefined') {\n        if (globalOptions.disabledTypes.indexOf(type) > -1) {\n            throw new TypeError('disabled file type: ' + type);\n        }\n        // find an appropriate handler for this file type\n        if (type in types_1.typeHandlers) {\n            const size = types_1.typeHandlers[type].calculate(buffer, filepath);\n            if (size !== undefined) {\n                size.type = type;\n                return size;\n            }\n        }\n    }\n    // throw up, if we don't understand the file\n    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n * @param {String} filepath\n * @returns {Promise<Buffer>}\n */\nasync function asyncFileToBuffer(filepath) {\n    const handle = await fs.promises.open(filepath, 'r');\n    try {\n        const { size } = await handle.stat();\n        if (size <= 0) {\n            throw new Error('Empty file');\n        }\n        const bufferSize = Math.min(size, MaxBufferSize);\n        const buffer = Buffer.alloc(bufferSize);\n        await handle.read(buffer, 0, bufferSize, 0);\n        return buffer;\n    }\n    finally {\n        await handle.close();\n    }\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\nfunction syncFileToBuffer(filepath) {\n    // read from the file, synchronously\n    const descriptor = fs.openSync(filepath, 'r');\n    try {\n        const { size } = fs.fstatSync(descriptor);\n        if (size <= 0) {\n            throw new Error('Empty file');\n        }\n        const bufferSize = Math.min(size, MaxBufferSize);\n        const buffer = Buffer.alloc(bufferSize);\n        fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n        return buffer;\n    }\n    finally {\n        fs.closeSync(descriptor);\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nmodule.exports = exports = imageSize; // backwards compatibility\nexports.default = imageSize;\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} [callback] - optional function for async detection\n */\nfunction imageSize(input, callback) {\n    // Handle buffer input\n    if (Buffer.isBuffer(input)) {\n        return lookup(input);\n    }\n    // input should be a string at this point\n    if (typeof input !== 'string' || globalOptions.disabledFS) {\n        throw new TypeError('invalid invocation. input should be a Buffer');\n    }\n    // resolve the file path\n    const filepath = path.resolve(input);\n    if (typeof callback === 'function') {\n        queue.push(() => asyncFileToBuffer(filepath)\n            .then((buffer) => process.nextTick(callback, null, lookup(buffer, filepath)))\n            .catch(callback));\n    }\n    else {\n        const buffer = syncFileToBuffer(filepath);\n        return lookup(buffer, filepath);\n    }\n}\nexports.imageSize = imageSize;\nconst disableFS = (v) => { globalOptions.disabledFS = v; };\nexports.disableFS = disableFS;\nconst disableTypes = (types) => { globalOptions.disabledTypes = types; };\nexports.disableTypes = disableTypes;\nconst setConcurrency = (c) => { queue.concurrency = c; };\nexports.setConcurrency = setConcurrency;\nexports.types = Object.keys(types_1.typeHandlers);\n"],
  "mappings": "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",
  "names": ["ReflectApply", "ReflectOwnKeys", "NumberIsNaN", "once"]
}
